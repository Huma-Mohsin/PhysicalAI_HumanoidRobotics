---
id: module-1-ros2
title: "Module 1: The Robotic Nervous System (ROS 2)"
sidebar_label: "Module 1: ROS 2"
sidebar_position: 3
---

import TranslationToggle from '@site/src/components/Translation/TranslationToggle';
import PersonalizeButton from '@site/src/components/Personalization/PersonalizeButton';
import ContentVariant from '@site/src/components/Personalization/ContentVariant';

<div style={{display: 'flex', justifyContent: 'flex-end', marginBottom: '1rem'}}>
  <TranslationToggle />
</div>

# Module 1: The Robotic Nervous System (ROS 2)

## Overview

**Focus**: Middleware for robot control

ROS 2 (Robot Operating System 2) is the industry-standard middleware that enables modular robot software development. Think of it as the "nervous system" that coordinates all the different parts of a robotâ€”sensors, actuators, planning algorithms, and AI models.

---

## Learning Objectives

By the end of this module, you will:

1. âœ… Understand ROS 2 architecture and core concepts
2. âœ… Build ROS 2 Nodes, Topics, and Services
3. âœ… Bridge Python AI Agents to ROS controllers using `rclpy`
4. âœ… Master URDF (Unified Robot Description Format) for humanoids
5. âœ… Create launch files and manage parameters
6. âœ… Build and deploy ROS 2 packages

---

<PersonalizeButton />

---

## Installation Guide for Your Setup

<ContentVariant hardwareType="gpu_workstation">

### Installing ROS 2 on GPU Workstation (Ubuntu 22.04)

**You have the ideal setup for ROS 2 development!** Native installation with full performance.

```bash
# Update system
sudo apt update && sudo apt upgrade -y

# Add ROS 2 apt repository
sudo apt install software-properties-common
sudo add-apt-repository universe
sudo apt update && sudo apt install curl -y

# Add ROS 2 GPG key
sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg

# Add repository to sources list
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null

# Install ROS 2 Humble (Full Desktop)
sudo apt update
sudo apt install ros-humble-desktop-full -y

# Install development tools
sudo apt install python3-colcon-common-extensions python3-rosdep -y

# Initialize rosdep
sudo rosdep init
rosdep update

# Source ROS 2 (add to ~/.bashrc for persistence)
echo "source /opt/ros/humble/setup.bash" >> ~/.bashrc
source ~/.bashrc
```

**Verify Installation:**
```bash
ros2 run demo_nodes_cpp talker  # Terminal 1
ros2 run demo_nodes_py listener  # Terminal 2
```

**Your Advantage:** Full ROS 2 toolchain with native performance.

</ContentVariant>

<ContentVariant hardwareType="edge_device">

### Installing ROS 2 on Jetson (JetPack 5.1+)

**Optimized ROS 2 installation for Jetson hardware with Isaac ROS support.**

```bash
# Verify JetPack version
sudo apt-cache show nvidia-jetpack

# Add ROS 2 apt repository (ARM64)
sudo apt update && sudo apt install curl -y
sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg

echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu jammy main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null

# Install ROS 2 Humble (Base + essentials for Jetson)
sudo apt update
sudo apt install ros-humble-ros-base -y
sudo apt install ros-humble-vision-msgs ros-humble-sensor-msgs -y

# Install Isaac ROS dependencies
sudo apt install python3-colcon-common-extensions -y

# Source ROS 2
echo "source /opt/ros/humble/setup.bash" >> ~/.bashrc
source ~/.bashrc
```

**Memory Optimization for Jetson:**
```bash
# Reduce colcon build parallelism (prevent OOM)
echo "export COLCON_DEFAULTS='--parallel-workers 2'" >> ~/.bashrc
```

**Your Advantage:** Embedded deployment experience with real hardware constraints.

</ContentVariant>

<ContentVariant hardwareType="cloud_mac">

### Installing ROS 2 via Docker (Mac/Windows/Cloud)

**Use Docker for cross-platform ROS 2 development.**

**Step 1: Install Docker Desktop**
- Download from [docker.com](https://www.docker.com/products/docker-desktop)
- Enable WSL 2 (Windows) or Rosetta (Mac M1/M2)

**Step 2: Pull ROS 2 Image**
```bash
docker pull osrf/ros:humble-desktop-full
```

**Step 3: Run ROS 2 Container**
```bash
# Run with GUI support (X11 forwarding)
docker run -it --rm \
  --name ros2-dev \
  -v $(pwd):/workspace \
  osrf/ros:humble-desktop-full \
  bash

# Inside container:
source /opt/ros/humble/setup.bash
ros2 run demo_nodes_cpp talker
```

**Mac-Specific:** GUI apps won't work natively. Use XQuartz for visualization or develop without GUI.

**Your Advantage:** Platform-independent learning, deploy to cloud robots.

</ContentVariant>

---

## Why ROS 2?

### The Evolution from ROS 1

ROS 2 was built from the ground up to address the limitations of ROS 1:

| Feature | ROS 1 | ROS 2 |
|---------|-------|-------|
| **Communication** | Single master node (SPOF) | DDS (Data Distribution Service) - decentralized |
| **Real-time** | No real-time support | Real-time capabilities with RTOS |
| **Multi-robot** | Difficult | Native support |
| **Security** | None | Secure DDS with encryption |
| **Cross-platform** | Linux only | Linux, Windows, macOS |
| **Language Support** | C++, Python | C++, Python, Rust, Java |

---

## Core ROS 2 Concepts

### 1. Nodes

A **Node** is a single-purpose executable program that performs computation.

```python
import rclpy
from rclpy.node import Node

class MinimalNode(Node):
    def __init__(self):
        super().__init__('minimal_node')
        self.get_logger().info('Node has been started!')

def main(args=None):
    rclpy.init(args=args)
    node = MinimalNode()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

:::tip Best Practice
Each node should have a single, well-defined purpose. For example:
- Camera driver node
- Object detection node
- Motion planning node
- Motor control node
:::

---

### 2. Topics (Publish/Subscribe)

**Topics** enable asynchronous many-to-many communication between nodes.

```python
from std_msgs.msg import String

class PublisherNode(Node):
    def __init__(self):
        super().__init__('publisher_node')
        self.publisher_ = self.create_publisher(String, 'topic_name', 10)
        self.timer = self.create_timer(1.0, self.timer_callback)
        self.counter = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello ROS 2: {self.counter}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.counter += 1
```

**Subscriber:**

```python
class SubscriberNode(Node):
    def __init__(self):
        super().__init__('subscriber_node')
        self.subscription = self.create_subscription(
            String,
            'topic_name',
            self.listener_callback,
            10
        )

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')
```

---

### 3. Services (Request/Response)

**Services** enable synchronous request/response communication.

```python
from example_interfaces.srv import AddTwoInts

class ServiceNode(Node):
    def __init__(self):
        super().__init__('service_node')
        self.srv = self.create_service(
            AddTwoInts,
            'add_two_ints',
            self.add_two_ints_callback
        )

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'{request.a} + {request.b} = {response.sum}')
        return response
```

**Service Client:**

```python
import sys

class ClientNode(Node):
    def __init__(self):
        super().__init__('client_node')
        self.client = self.create_client(AddTwoInts, 'add_two_ints')

        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for service...')

        self.request = AddTwoInts.Request()

    def send_request(self, a, b):
        self.request.a = a
        self.request.b = b
        self.future = self.client.call_async(self.request)
        return self.future
```

---

### 4. Actions (Long-Running Tasks)

**Actions** are for long-running tasks with feedback and the ability to cancel.

```python
from action_tutorials_interfaces.action import Fibonacci
from rclpy.action import ActionServer

class FibonacciActionServer(Node):
    def __init__(self):
        super().__init__('fibonacci_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            self.execute_callback
        )

    async def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')

        # Provide feedback
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.partial_sequence = [0, 1]

        for i in range(1, goal_handle.request.order):
            # Check if goal was cancelled
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                return Fibonacci.Result()

            # Compute next Fibonacci number
            feedback_msg.partial_sequence.append(
                feedback_msg.partial_sequence[i] +
                feedback_msg.partial_sequence[i-1]
            )

            # Publish feedback
            goal_handle.publish_feedback(feedback_msg)
            await asyncio.sleep(1)

        # Mark goal as succeeded
        goal_handle.succeed()

        # Return result
        result = Fibonacci.Result()
        result.sequence = feedback_msg.partial_sequence
        return result
```

---

## Bridging Python AI Agents to ROS

One of the most powerful aspects of ROS 2 is the ability to integrate AI models directly into the robot control loop.

### Example: GPT-4 as a Robot Controller

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from geometry_msgs.msg import Twist
import openai

class GPTRobotController(Node):
    def __init__(self):
        super().__init__('gpt_robot_controller')

        # Subscribe to voice commands
        self.voice_sub = self.create_subscription(
            String,
            '/voice_command',
            self.voice_callback,
            10
        )

        # Publish velocity commands
        self.cmd_vel_pub = self.create_publisher(
            Twist,
            '/cmd_vel',
            10
        )

        # OpenAI client
        self.client = openai.OpenAI()

    def voice_callback(self, msg):
        command = msg.data
        self.get_logger().info(f'Received command: {command}')

        # Ask GPT-4 to translate to robot actions
        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are a robot controller. Translate human commands to robot motion commands: forward, backward, turn_left, turn_right, stop."},
                {"role": "user", "content": command}
            ]
        )

        action = response.choices[0].message.content.strip().lower()
        self.execute_action(action)

    def execute_action(self, action):
        twist = Twist()

        if action == "forward":
            twist.linear.x = 0.5
        elif action == "backward":
            twist.linear.x = -0.5
        elif action == "turn_left":
            twist.angular.z = 0.5
        elif action == "turn_right":
            twist.angular.z = -0.5
        elif action == "stop":
            twist.linear.x = 0.0
            twist.angular.z = 0.0

        self.cmd_vel_pub.publish(twist)
        self.get_logger().info(f'Executing: {action}')
```

---

## URDF (Unified Robot Description Format)

URDF is an XML format for describing robot geometry, kinematics, dynamics, and visual appearance.

### Basic URDF Structure

```xml
<?xml version="1.0"?>
<robot name="simple_humanoid">

  <!-- Base Link -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.3 0.3 0.1"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 1 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <box size="0.3 0.3 0.1"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="10.0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0"
               iyy="0.1" iyz="0.0" izz="0.1"/>
    </inertial>
  </link>

  <!-- Torso Link -->
  <link name="torso">
    <visual>
      <geometry>
        <cylinder radius="0.15" length="0.6"/>
      </geometry>
      <material name="white">
        <color rgba="1 1 1 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder radius="0.15" length="0.6"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="15.0"/>
      <inertia ixx="0.5" ixy="0.0" ixz="0.0"
               iyy="0.5" iyz="0.0" izz="0.1"/>
    </inertial>
  </link>

  <!-- Joint connecting base to torso -->
  <joint name="base_to_torso" type="fixed">
    <parent link="base_link"/>
    <child link="torso"/>
    <origin xyz="0 0 0.35" rpy="0 0 0"/>
  </joint>

  <!-- Right Leg -->
  <link name="right_leg">
    <visual>
      <geometry>
        <cylinder radius="0.05" length="0.8"/>
      </geometry>
      <material name="gray">
        <color rgba="0.5 0.5 0.5 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder radius="0.05" length="0.8"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="5.0"/>
      <inertia ixx="0.2" ixy="0.0" ixz="0.0"
               iyy="0.2" iyz="0.0" izz="0.01"/>
    </inertial>
  </link>

  <!-- Hip Joint (Revolute) -->
  <joint name="right_hip" type="revolute">
    <parent link="base_link"/>
    <child link="right_leg"/>
    <origin xyz="0.1 -0.1 -0.05" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="-1.57" upper="1.57" effort="100" velocity="1.0"/>
  </joint>

</robot>
```

:::tip URDF Visualization
Use `urdf_to_graphviz` to visualize your robot structure:

```bash
urdf_to_graphviz my_robot.urdf
```
:::

---

## Launch Files

Launch files allow you to start multiple nodes with complex configurations.

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_robot_pkg',
            executable='camera_driver',
            name='camera',
            parameters=[{'frame_rate': 30}]
        ),
        Node(
            package='my_robot_pkg',
            executable='object_detector',
            name='detector',
            parameters=[{'confidence_threshold': 0.7}]
        ),
        Node(
            package='my_robot_pkg',
            executable='motion_planner',
            name='planner',
            output='screen'
        ),
    ])
```

---

## Hands-On Project: Build a Humanoid Controller

### Project Requirements

Create a ROS 2 package that:

1. âœ… Subscribes to joint commands
2. âœ… Publishes joint states
3. âœ… Provides a service to move the robot to a target pose
4. âœ… Loads a humanoid URDF model
5. âœ… Launches all nodes with a single launch file

### Assessment Criteria

- Code quality and documentation
- Proper use of ROS 2 best practices
- URDF model correctness
- Launch file functionality

---

## Resources

- [ROS 2 Official Documentation](https://docs.ros.org/en/humble/)
- [rclpy API Reference](https://docs.ros.org/en/humble/p/rclpy/)
- [URDF Tutorials](http://wiki.ros.org/urdf/Tutorials)
- [ROS 2 Design](https://design.ros2.org/)

---

## Next Steps

Now that you understand ROS 2, let's explore how to simulate robots in realistic physics environments.

ðŸ‘‰ **Next**: [Module 2: The Digital Twin (Gazebo & Unity)](./module-2-gazebo-unity)
